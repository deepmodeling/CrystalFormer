wyckoff_list = [[1],                          # 1
                [1, 1, 1, 1, 1, 1, 1, 1, 2],  # 2
                [1, 1, 1, 1, 2],              # 3 
                [2],              # 4 
                [2, 2, 4],  # 5 
                [1, 2, 2],  # 6 
                [2],        # 7 
                [2, 4],     # 8 
                [4], # 9 
                [1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 4], # 10
                [2, 2, 2, 2, 2, 4], # 11 
                [2, 2, 2, 2, 4, 4, 4, 4, 8], # 12 
                [2, 2, 2, 2, 2, 2, 4], # 13
                [2, 2, 2, 2, 4], # 14 
                [4,4,4,4,4,8], # 15
                [1]*8 + [2]*12 + [4], # 16
                [2]*4 + [4], # 17
                [2, 2, 4], # 18
                [4], # 19
                [4, 4, 8], # 20 
                [2]*4 + [4]*7 + [8], # 21
                [4]*4 + [8]*6 + [16], # 22
                [2]*4 + [4]*6 + [8], # 23 
                [4, 4, 4, 8], # 24
                [1]*4 + [2]*4 + [4], # 25
                [2, 2, 4], # 26 
                [2, 2, 2, 2, 4] , # 27
                [2, 2, 2, 4] , # 28
                [4], # 29 
                [2, 2, 4], # 30
                [2, 4], # 31
                [2, 2, 4], # 32
                [4],  # 33 
                [2, 2, 4], #34
                [2, 2, 4, 4, 4, 8], # 35
                [4, 8], # 36 
                [4, 4, 4, 8] , # 37
                [2, 2, 4, 4, 8], # 38
                [4, 4, 4, 8], # 39
                [4, 4, 8], # 40
                [4, 8], # 41
                [4, 8, 8, 8, 16], # 42
                [8, 16], # 43 
                [2, 2, 4, 4, 8], # 44
                [4, 4, 8], # 45
                [4, 4, 8], # 46 
                [1]*8 + [2]*12 + [4]*6 + [8], # 47
                [2]*4 + [4]*8 + [8], # 48
                [2]*8 + [4]*9 + [8], # 49
                [2]*4 + [8]*4 + [8], # 50
                [0], # 51
                [0], # 52
                [0], # 53
                [0], # 54
                [0], # 55
                [0], # 56
                [0], # 57 
                [0], # 58 
                [0], # 59
                [0], # 60
                [0], # 61
                [0], # 62
                [0], # 63
                [0], # 64
                [0], # 65
                [0], # 66
                [0], # 67
                [0], # 68
                [0], # 69
                [0], # 70
                [0], # 71
                [0], # 72
                [0], # 73
                [0], # 74
                [0], # 75
                [0], # 76
                [0], # 77
                [0], # 78
                [0], # 79
                [0], # 80
                [0], # 81
                [0], # 82
                [0], # 83
                [0], # 84
                [0], # 85
                [0], # 86
                [0], # 87
                [0], # 88
                [0], # 89
                [0], # 90
                [0], # 91
                [0], # 92
                [0], # 93
                [0], # 94
                [0], # 95
                [0], # 96
                [0], # 97
                [0], # 98
                [1, 1, 2, 4, 4, 4, 8], # 99
                [0], # 100
                [0], # 101
                [0], # 102
                [0], # 103
                [0], # 104
                [0], # 105
                [0], # 106
                [0], # 107
                [0], # 108
                [0], # 109
                [0], # 110
                [0], # 111
                [0], # 112
                [0], # 113
                [0], # 114
                [0], # 115
                [0], # 116
                [0], # 117
                [0], # 118
                [0], # 119
                [0], # 120
                [0], # 121
                [0], # 122
                [1]*4 + [2]*4 + [4]*7 + [8]*5 + [16], # 123
                [0], # 124
                [0], # 125
                [0], # 126
                [0], # 127
                [0], # 128
                [0], # 129
                [0], # 130
                [0], # 131
                [0], # 132 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [1]*2 + [3]*2 + [6]*2 + [8] + [12]*3 + [24]*3 + [48], # 221 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                [0], # 
                ]

from config import *
def test_mult_table():
    from crystalformer.src.wyckoff import mult_table

    def nonzero_part(arr):
        nonzero_indices = jnp.nonzero(arr)
        return arr[nonzero_indices]

    def match(g):
        jnp.allclose( nonzero_part(mult_table[g-1]) , jnp.array(wyckoff_list[g-1]))

    match(25)
    match(47)
    match(99)
    match(123)
    match(221)

def test_wyckoff():
    import pandas as pd
    import os

    df = pd.read_csv(os.path.join(datadir, 'wyckoff_symbols.csv'))
    df['Wyckoff Positions'] = df['Wyckoff Positions'].apply(eval)  # convert string to list

    wyckoff_symbols = df['Wyckoff Positions'].tolist()

    import numpy as np
    import jax.numpy as jnp

    wyckoff_list = []
    wyckoff_dict = []
    for ws in wyckoff_symbols:
        wyckoff_list.append( [0] +[0 if w == "" else int(''.join(filter(str.isdigit, w))) for w in ws] )

        ws = [""] + ws
        wyckoff_dict.append( {value: index for index, value in enumerate(ws)} )

    max_len = max(len(sublist) for sublist in wyckoff_list)
    mult_table = np.zeros((len(wyckoff_list), max_len), dtype=int) # mult_table[g-1, w] = multiplicity 
    wmax_table = np.zeros((len(wyckoff_list),), dtype=int)   # wmax_table[g-1] = number of wyckoff letters 
    for i, sublist in enumerate(wyckoff_list):
        mult_table[i, :len(sublist)] = sublist
        wmax_table[i] = len(sublist)-1
    mult_table = jnp.array(mult_table)
    wmax_table = jnp.array(wmax_table)
    
    import crystalformer.src.wyckoff as wyckoff
    assert jnp.allclose(mult_table, wyckoff.mult_table)
    assert jnp.allclose(wmax_table, wyckoff.wmax_table)

def test_symmetrize_atoms():
    from crystalformer.src.wyckoff import symmetrize_atoms, mult_table, wmax_table, symops
    from pymatgen.symmetry.groups import SpaceGroup

    #https://github.com/materialsproject/pymatgen/blob/1e347c42c01a4e926e15b910cca8964c1a0cc826/pymatgen/symmetry/groups.py#L547
    def in_array_list(array_list: list[np.ndarray], arr: np.ndarray, tol: float = 1e-5) -> bool:
        """Extremely efficient nd-array comparison using numpy's broadcasting. This
        function checks if a particular array a, is present in a list of arrays.
        It works for arrays of any size, e.g., even matrix searches.

        Args:
            array_list ([array]): A list of arrays to compare to.
            arr (array): The test array for comparison.
            tol (float): The tolerance. Defaults to 1e-5. If 0, an exact match is done.

        Returns:
            (bool)
        """
        if len(array_list) == 0:
            return False
        axes = tuple(range(1, arr.ndim + 1))
        if not tol:
            return any(np.all(array_list == arr[None, :], axes))
        return any(np.sum(np.abs(array_list - arr[None, :]), axes) < tol)

    def symmetrize_atoms_deduplication(g, w, x):
        '''
        symmetrize atoms via deduplication
        this implements the same method as pmg get_orbit function, see
        #https://github.com/materialsproject/pymatgen/blob/1e347c42c01a4e926e15b910cca8964c1a0cc826/pymatgen/symmetry/groups.py#L328
        Args:
           g: int 
           w: int
           x: (3,)
        Returns:
           xs: (m, 3)  symmetrized atom positions
        '''
        # (1) apply all space group symmetry ops to x 
        w_max = wmax_table[g-1].item()
        m_max = mult_table[g-1, w_max].item()
        ops = symops[g-1, w_max, :m_max] # (m_max, 3, 4)
        affine_point = jnp.array([*x, 1]) # (4, )
        coords = ops@affine_point # (m_max, 3) 
        
        # (2) deduplication to select the orbit 
        orbit: list[np.ndarray] = []
        for pp in coords:
            pp = np.mod(np.round(pp, decimals=10), 1) # round and mod to avoid duplication
            if not in_array_list(orbit, pp):
                orbit.append(pp)
        orbit -= np.floor(orbit)   # wrap back to 0-1 
        assert (orbit.shape[0] == mult_table[g-1, w]) # double check that the orbit has the right length
        return orbit

    def symmetrize_atoms_pmg(g, w, x):
        sg = SpaceGroup.from_int_number(g)
        xs = sg.get_orbit(x)
        m = mult_table[g-1, w]  
        assert (len(xs) == m) # double check that the orbit has the right length
        return np.array(xs)

    def allclose_up_to_permutation(xs, xs_pmg):
        # Sort each array lexicographically by rows
        sorted_xs = xs[np.lexsort(np.rot90(xs))]
        sorted_xs_pmg = xs_pmg[np.lexsort(np.rot90(xs_pmg))]
        # Check if the sorted arrays are equal
        return np.allclose(sorted_xs, sorted_xs_pmg)
 
    g = 166 
    w = jnp.array(3)
    x = jnp.array([0., 0., 0.5619])
    xs = symmetrize_atoms(g, w, x)
    print ('xs:\n', xs)
    assert allclose_up_to_permutation(xs, symmetrize_atoms_pmg(g, w, x))
    assert allclose_up_to_permutation(xs, symmetrize_atoms_deduplication(g, w, x))

    g = 225
    w = jnp.array(5)
    x = jnp.array([0., 0., 0.7334])
    xs = symmetrize_atoms(g, w, x)
    print ('xs:\n', xs)
    assert allclose_up_to_permutation(xs, symmetrize_atoms_pmg(g, w, x))
    assert allclose_up_to_permutation(xs, symmetrize_atoms_deduplication(g, w, x))

    g = 225
    w = jnp.array(8)
    x = jnp.array([0.0, 0.23, 0.23])
    xs = symmetrize_atoms(g, w, x)
    print ('xs:\n', xs)
    assert allclose_up_to_permutation(xs, symmetrize_atoms_pmg(g, w, x))
    assert allclose_up_to_permutation(xs, symmetrize_atoms_deduplication(g, w, x))

test_symmetrize_atoms()
test_wyckoff()


